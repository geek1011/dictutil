package kobodict

import (
	"strconv"
	"testing"
)

func TestNormalizeWordReference(t *testing.T) {
	for _, tc := range []struct {
		v    bool
		i, o string
	}{
		{true, "Asd", "asd"},
		{false, "Asd", "Asd"},
		{true, " Asd", "asd"},
		{false, " Asd", "Asd"},
		{true, " Asd ", "asd"},
		{false, " Asd ", "Asd"},
		{true, " Asd \n", "asd"},
		{false, " Asd \n", "Asd"},
		{true, " Ȃsd \n", "ȃsd"},
		{false, " Ȃsd \n", "Ȃsd"},
	} {
		t.Logf("word %#v [variant:%t] (%#v)", tc.i, tc.v, tc.o)
		if o := NormalizeWordReference(tc.i, tc.v); o != tc.o {
			t.Errorf("    got %#v", o)
		}
	}
}

var tcs = []struct{ w, p string }{
	// dicthtml-en
	{"test", "te"},
	{"a-", "11"},
	{"-an", "11"},
	{"GB", "gb"},

	// dicthtml-fr
	{"ébahir", "éb"},
	{"à", "àa"},
	{"a1", "11"},
	{"ô", "ôa"},
	{"kébab", "ké"},
	{"aérer", "aé"},
	{"living-room", "li"},

	// dicthtml-ja
	// Note, Kanji not currently implemented, so not testing (note, the logic
	// is in a separate function, anyways).
	// {"あ", "あ"},
	// {"アークとう", "アー"},

	// generated by dictword-test: spaces
	{" x", "xa"},
	{" ", "11"},
	{"x ", "xa"},
	{"  ", "11"},
	{"   ", "11"},
	{"\t\t", "11"},
	{"\t\f\t", "11"},
	{"x ", "xa"},
	{" xx", "xa"},

	// generated by dictword-test: spaces where trim/prefix order matters
	{"  x", "11"},
	{"  xy", "11"},
	{"  xyz", "11"},
	{"x z", "xa"},
	{"x z", "xa"},

	// generated by dictword-test: cyrillic
	{" д", "д"},
	{"д ", "д"},
	{" ", "11"},
	{"  ", "11"},
	{"   ", "11"},
	{" дд", "д"},
	{"д ", "д"},
	{"д", "д"},
	{"aд", "aд"},
	{"дa", "дa"},
	{"aдa", "aд"},
	{"дaд", "дa"},

	// generated by dictword-test: uppercase accented letters
	{"Ȅe", "ȅe"},
	{"eȄ", "eȅ"},
	{"Ȅ", "ȅa"},
	{"Ȅ!", "11"},

	// generated by dictword-test: cjk
	{" 未", "未a"},
	{"  未", "11"},
	{"未", "未a"},
	{"未未", "未未"},
	{"x未", "x未"},
	{"未x", "未x"},
	{"xy未", "xy"},
	{"还没", "还没"},

	// generated by dictword-test: misc
	{"!", "11"},
	{"!!", "11"},
	{"!!!", "11"},
	{"x!", "11"},
	{"x!!", "11"},
	{"xx!", "xx"},
	{"xxx!", "xx"},
	{"  !", "11"},
	{" !!", "11"},
	{" !!!", "11"},
	{" !", "11"},
	{"  !!", "11"},
	{"   !!!", "11"},
	{" x!", "xa"},
	{" x!!", "xa"},
	{" xx!", "xa"},
	{" xxx!", "xa"},

	// synthetic
	{"x\x00y", "xa"},
	{"\x00xy", "11"},
}

func TestWordPrefix(t *testing.T) {
	for _, tc := range tcs {
		t.Logf("word %#v (%#v)", tc.w, tc.p)
		if p := wordPrefix(tc.w); p != tc.p {
			t.Errorf("    got (original version) %#v", p)
		}
		if p := WordPrefix(tc.w); p != tc.p {
			t.Errorf("    got (simplified version) %#v", p)
		}
	}
}

func BenchmarkWordPrefix(b *testing.B) {
	for _, tcf := range []struct {
		n  string
		fn func(string) string
	}{
		{"Orig/", wordPrefix},
		{"Smpl/", WordPrefix},
	} {
		// all test cases
		b.Run(tcf.n+"All"+strconv.Itoa(len(tcs)), func(b *testing.B) {
			for i := 0; i < b.N; i++ {
				for _, tc := range tcs {
					tcf.fn(tc.w)
				}
			}
		})

		// near-worst possible case
		b.Run(tcf.n+"Worst", func(b *testing.B) {
			for i := 0; i < b.N; i++ {
				tcf.fn(" 还д 没")
			}
		})

		// normal case
		b.Run(tcf.n+"Normal", func(b *testing.B) {
			for i := 0; i < b.N; i++ {
				tcf.fn("Test")
			}
		})

		// best case
		b.Run(tcf.n+"Best", func(b *testing.B) {
			for i := 0; i < b.N; i++ {
				tcf.fn("aa")
			}
		})
	}
}
